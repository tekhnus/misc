#!/usr/bin/env python
import sys
import dataclasses
import sexpdata


@dataclasses.dataclass
class State:
    varz: list = dataclasses.field(default_factory=list)
    stak: list = dataclasses.field(default_factory=list)
    ip: int = 0


def is_true(tagged_value):
    return bool(check_is_value(tagged_value))


def check_is_value(tagged_value):
    return tagged_value


def check_is_routine_0(tagged_value):
    offset, varz_and_stack = check_is_value(tagged_value)
    offset = check_is_value(offset)
    varz, stack = check_is_value(varz_and_stack)
    varz = check_is_value(varz)
    stack = check_is_value(stack)
    return offset, (varz, stack)


def check_is_cons(tagged_value):
    val = check_is_value(tagged_value)
    return val[0], make_value(val[1:])


def make_list_with_items(*args):
    return make_value(list(args))


def make_value(x):
    return x


def make_routine_0(ip, varz, stak):
    return make_list_with_items(make_value(ip), make_list_with_items(make_value(varz), make_value(stak)))


def make_symbol(s):
    return make_value(sexpdata.Symbol(s))


def get_var(d, k):
    for k_, v in reversed(d):
        if k_ == k:
            return v
    raise KeyError(k)


def head(args):
    a1, ar = check_is_cons(args)
    h, t = check_is_cons(a1)
    return h


def tail(args):
    a1, ar = check_is_cons(args)
    h, t = check_is_cons(a1)
    return t


def is_constant(args):
    a1, ar = check_is_cons(args)
    v = check_is_value(a1)
    if isinstance(v, list):
        return make_list_with_items()
    if isinstance(v, sexpdata.Symbol) and str(v)[0] != ":":
        return make_list_with_items()
    return make_list_with_items(make_list_with_items())


def eq(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    if a1 == a2:
        return make_list_with_items(make_list_with_items())
    return make_list_with_items()


def panic(args):
    a1, ar = check_is_cons(args)
    raise RuntimeError("Panic! {}".format(repr(a1)))


def annotate(args):
    a1, ar = check_is_cons(args)
    val = check_is_value(a1)
    if isinstance(val, list):
        r = ":list"
    elif isinstance(val, sexpdata.Symbol):
        r = ":symbol"
    elif isinstance(val, str):
        r = ":bytestring"
    elif isinstance(val, int):
        r = ":integer"
    else:
        raise RuntimeError("cannot annotate {}".format(repr(a1)))
    return make_list_with_items(make_symbol(r), a1)


def add(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    x = check_is_value(a1)
    y = check_is_value(a2)
    return make_value(x + y)


def cons(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    if a1 == a2:
        return make_list_with_items(make_list_with_items())
    a2items = check_is_value(a2)
    return make_list_with_items(a1, *a2items)


def concat_bytestrings(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    x = check_is_value(a1)
    y = check_is_value(a2)
    return make_value(x + y)


def repre(args):
    a1, ar = check_is_cons(args)
    return make_value(repr(a1))


def main():
    bc = sys.stdin.read()
    prog = sexpdata.loads(bc)
    ip = 0
    pdata = [[State()]]
    def pop_stack():
        return pdata[-1][-1].stak.pop()
    while True:
        ip = pdata[-1][-1].ip
        ins = prog[ip]
        # print(ins)
        op, args = ins[0], ins[1:]
        if op == sexpdata.Symbol(":end"):
            if len(pdata) != 1 or len(pdata[0]) != 1:
                raise RuntimeError("program ended, but the call stack is not empty")
            break
        elif op == sexpdata.Symbol(":if"):
            if_true, if_false = args
            if is_true(pop_stack()):
                ip = if_true
            else:
                ip = if_false
        elif op == sexpdata.Symbol(":nop"):
            nex, = args
            ip = nex
        elif op == sexpdata.Symbol(":put-const"):
            value, nex = args
            pdata[-1][-1].stak.append(value)
            ip = nex
        elif op == sexpdata.Symbol(":put-var"):
            value, nex = args
            pdata[-1][-1].stak.append(get_var(pdata[-1][-1].varz, value))
            ip = nex
        elif op == sexpdata.Symbol(":args"):
            nex, = args
            pdata[-1][-1].stak.append("__function_call")
            ip = nex
        elif op == sexpdata.Symbol(":call"):
            hat, nex = args
            if hat:
                raise RuntimeError("routine-1 call is not supported yet")
            fnandargs = pop_stack()
            rout, args = check_is_cons(fnandargs)
            offset, (varz, stack) = check_is_routine_0(rout)
            rtvarz = list(varz)
            rtstack = list(stack)
            rtstack.append(args)
            pdata[-1][-1].ip = nex
            pdata[-1].append(State(varz=rtvarz, stak=rtstack, ip=0))  # ip set after endif
            ip = offset
        elif op == sexpdata.Symbol(":host"):
            instruction, nex = args
            arg = pop_stack()
            if isinstance(instruction, list) and len(instruction) == 2 and instruction[0] == "eval":
                res = eval(instruction[1], globals(), {"x": arg})
                pdata[-1][-1].stak.append(res)
            else:
                raise RuntimeError(f"host not implemented: {instruction}")
            ip = nex
        elif op == sexpdata.Symbol(":collect"):
            nex, = args
            form = []
            while True:
                val = pop_stack()
                if val == "__function_call":
                    break
                form = [val] + form
            pdata[-1][-1].stak.append(make_value(form))
            ip = nex
        elif op == sexpdata.Symbol(":pop"):
            var, nex = args
            varname = check_is_value(var)
            if varname == sexpdata.Symbol(":void"):
                pop_stack()
            else:
                pdata[-1][-1].varz.append((var, pop_stack()))
            ip = nex
        elif op == sexpdata.Symbol(":set-closures"):
            pr, name, hat, nex = args
            if hat:
                raise RuntimeError("routine-1 set-closures is not supported yet")
            pvarz = list(pdata[-1][-1].varz)
            p = make_routine_0(pr, pvarz, [])
            pvarz.append((name, p))
            pdata[-1][-1].varz.append((name, p))
            ip = nex
        elif op == sexpdata.Symbol(":return"):
            hat, = args
            if hat:
                raise RuntimeError("routine-1 return is not supported yet")
            rvalue = pop_stack()
            pdata[-1].pop()
            pdata[-1][-1].stak.append(rvalue)
            ip = pdata[-1][-1].ip
        elif op == sexpdata.Symbol(":yield"):
            hat, nex = args
            rvalue = pop_stack()

            contvarz = list(pdata[-1][-1].varz)
            contstack = list(pdata[-1][-1].stak)
            cont = make_routine_0(varz=contvarz, stak=contstack, ip=nex)

            pdata[-1].pop()
            pdata[-1][-1].stak.append(make_list_with_items(rvalue, cont))
            ip = pdata[-1][-1].ip
        elif op == sexpdata.Symbol(":import"):
            nex, = args
            val = pop_stack()
            val = check_is_value(val)
            _, rout = val
            _, (varz, _) = check_is_routine_0(rout)
            pdata[-1][-1].varz.extend(varz)
            ip = nex
        else:
            raise RuntimeError(op)
        pdata[-1][-1].ip = ip



if __name__ == "__main__":
    main()
