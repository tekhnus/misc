#!/usr/bin/env python
import sys
import dataclasses
import sexpdata


@dataclasses.dataclass
class State:
    varz: list = dataclasses.field(default_factory=list)
    ip: int = 0


def is_true(tagged_value):
    return bool((tagged_value))


def check_is_routine_0(tagged_value):
    offset, varz = tagged_value
    return offset, varz


def check_is_cons(val):
    return val[0], (val[1:])


def make_list_with_items(*args):
    return list(args)


def make_routine_0(ip, varz):
    return make_list_with_items(ip, varz)


def make_symbol(s):
    return sexpdata.Symbol(s)


def get_var(d, offset):
    if not d:
        exit("get_var: not found")
    v = d[-1]
    if offset == 0:
        return v
    return get_var(d[:-1], offset - 1)


def head(args):
    a1, ar = check_is_cons(args)
    h, t = check_is_cons(a1)
    return h


def tail(args):
    a1, ar = check_is_cons(args)
    h, t = check_is_cons(a1)
    return t


def is_constant(args):
    v, ar = check_is_cons(args)
    if isinstance(v, list):
        return make_list_with_items()
    if isinstance(v, sexpdata.Symbol) and str(v)[0] != ":":
        return make_list_with_items()
    return make_list_with_items(make_list_with_items())


def eq(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    if a1 == a2:
        return make_list_with_items(make_list_with_items())
    return make_list_with_items()


def panic(args):
    a1, ar = check_is_cons(args)
    raise RuntimeError("Panic! {}".format(repr(a1)))


def annotate(args):
    val, ar = check_is_cons(args)
    if isinstance(val, list):
        r = ":list"
    elif isinstance(val, sexpdata.Symbol):
        r = ":symbol"
    elif isinstance(val, str):
        r = ":bytestring"
    elif isinstance(val, int):
        r = ":integer"
    else:
        raise RuntimeError("cannot annotate {}".format(repr(a1)))
    return make_list_with_items(make_symbol(r), val)


def add(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    return a1 + a2


def cons(args):
    a1, ar = check_is_cons(args)
    a2, arr = check_is_cons(ar)
    if a1 == a2:
        return make_list_with_items(make_list_with_items())
    return make_list_with_items(a1, *a2)


def concat_bytestrings(args):
    x, ar = check_is_cons(args)
    y, arr = check_is_cons(ar)
    return x + y


def repre(args):
    a1, ar = check_is_cons(args)
    return repr(a1)


def main():
    bc = sys.stdin.read()
    prog = sexpdata.loads(bc)
    ip = 0
    pdata = [[State()]]

    def pop_stack():
        v = pdata[-1][-1].varz.pop()
        return v

    while True:
        ip = pdata[-1][-1].ip
        ins = prog[ip]
        # print(ins)
        op, args = ins[0], ins[1:]
        if op == sexpdata.Symbol(":end"):
            break
        elif op == sexpdata.Symbol(":if"):
            if_true, if_false = args
            if is_true(pop_stack()):
                ip = if_true
            else:
                ip = if_false
        elif op == sexpdata.Symbol(":nop"):
            info, nex = args
            ip = nex
        elif op == sexpdata.Symbol(":put-const"):
            value, nex = args
            pdata[-1][-1].varz.append((value))
            ip = nex
        elif op == sexpdata.Symbol(":put-var"):
            offset, nex = args
            pdata[-1][-1].varz.append((get_var(pdata[-1][-1].varz, offset)))
            ip = nex
        elif op == sexpdata.Symbol(":call"):
            fn_index, hat, arg_cnt, ret_cnt, nex = args
            if hat == sexpdata.Symbol("hat"):
                raise RuntimeError("routine-1 call is not supported yet")
            if hat != sexpdata.Symbol("plain"):
                raise RuntimeError("unknown type of the call")
            args = list(reversed([pop_stack() for _ in range(arg_cnt)]))
            rout = pdata[-1][-1].varz[-1 - fn_index]
            offset, varz = check_is_routine_0(rout)
            rtvarz = list(varz)
            rtvarz.extend((arg) for arg in args)
            pdata[-1].append(
                State(varz=rtvarz, ip=0)
            )  # ip set after endif
            ip = offset
            # check that first instruction is yield and skip it
            ins = prog[ip]
            op, args = ins[0], ins[1:]
            if op != sexpdata.Symbol(":yield"):
                raise RuntimeError("expected a yield-reciever")
            hat, cnt, recieve_cnt, meta, nex = args
            if arg_cnt != recieve_cnt:
                raise RuntimeError("arg count and recieve count are different")
            ip = nex
        elif op == sexpdata.Symbol(":collect"):
            cnt, nex = args
            form = []
            for _ in range(cnt):
                val = pop_stack()
                form = [val] + form
            pdata[-1][-1].varz.append((form))
            ip = nex
        elif op == sexpdata.Symbol(":uncollect"):
            cnt, nex = args
            vals = pop_stack()
            for val in vals:
                pdata[-1][-1].varz.append(val)
            ip = nex
        elif op == sexpdata.Symbol(":pop"):
            idx, nex = args
            form = []
            for _ in range(idx):
                val = pop_stack()
                form = [val] + form
            pop_stack()
            pdata[-1][-1].varz.extend(form)
            ip = nex
        elif op == sexpdata.Symbol(":put-prog"):
            pr, capture, nex = args
            if capture == 0:
                capture_size = 0
            else:
                capture_size = len(pdata[-1][-1].varz) + 1
            p = make_list_with_items(pr, capture_size)
            pdata[-1][-1].varz.append((p))
            ip = nex
        elif op == sexpdata.Symbol(":resolve"):
            nex, = args
            fnptr = pdata[-1][-1].varz[-1]
            pr, stateptr = fnptr
            if stateptr > len(pdata[-1][-1].varz):
                raise RuntimeError("statptr is too big")
            cutvarz = pdata[-1][-1].varz[:stateptr]
            pop_stack()
            pdata[-1][-1].varz.append(make_list_with_items(pr, cutvarz))
            ip = nex
        elif op == sexpdata.Symbol(":yield"):
            hat, cnt, recieve_cnt, meta, nex = args
            if hat == sexpdata.Symbol("plain"):
                rvalues = [pop_stack() for _ in range(cnt)]

                contvarz = list(pdata[-1][-1].varz)
                cont = make_routine_0(varz=contvarz, ip=ip)

                pdata[-1].pop()

                ip = pdata[-1][-1].ip
                ins = prog[ip]
                op, args = ins[0], ins[1:]
                if op != sexpdata.Symbol(":call"):
                    raise RuntimeError("expected a call")
                fn_index, hat, arg_cnt, ret_cnt, nex = args

                # update the routine
                pdata[-1][-1].varz[-1 - fn_index] = cont
                pdata[-1][-1].varz.extend((make_list_with_items(*reversed(rvalues))))

                ip = nex
            elif hat == sexpdata.Symbol("host"):
                instruction = meta
                arg = pop_stack()
                if (
                        isinstance(instruction, list)
                        and len(instruction) == 2
                        and instruction[0] == "eval"
                ):
                    res = eval(instruction[1], globals(), {"x": arg})
                    pdata[-1][-1].varz.append((res))
                else:
                    raise RuntimeError(f"host not implemented: {instruction}")
                ip = nex
            else:
                raise RuntimeError("invalid yield")
        else:
            raise RuntimeError(op)
        pdata[-1][-1].ip = ip


if __name__ == "__main__":
    main()
