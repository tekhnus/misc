#!/usr/bin/env python
import sys
import dataclasses
import sexpdata
import copy


@dataclasses.dataclass
class State:
    varz: list = dataclasses.field(default_factory=lambda: [[]])
    ip: int = 0


def head(args):
    (a1,) = args
    h, *t = a1
    return h


def tail(args):
    (a1,) = args
    h, *t = a1
    return t


def is_constant(args):
    (v,) = args
    if isinstance(v, list):
        return []
    if isinstance(v, sexpdata.Symbol) and str(v)[0] != ":":
        return []
    return [[]]


def eq(args):
    a1, a2 = args
    if a1 == a2:
        return [[]]
    return []


def panic(args):
    (a1,) = args
    raise RuntimeError("Panic! {}".format(repr(a1)))


def annotate(args):
    (val,) = args
    if isinstance(val, list):
        r = ":list"
    elif isinstance(val, sexpdata.Symbol):
        r = ":symbol"
    elif isinstance(val, str):
        r = ":bytestring"
    elif isinstance(val, int):
        r = ":integer"
    else:
        raise RuntimeError("cannot annotate {}".format(repr(a1)))
    return [sexpdata.Symbol(r), val]


def add(args):
    a1, a2 = args
    return a1 + a2


def cons(args):
    a1, a2 = args
    return [a1, *a2]


def concat_bytestrings(args):
    x, y = args
    return x + y


def repre(args):
    (a1,) = args
    return repr(a1)


def merge(x, y, extvars):
    rtvarz = []
    for fra in x:
        if extvars <= 0:
            break
        rtvarz.append(copy.copy(fra))
        extvars -= 1
    if extvars > 0:
        raise RuntimeError("not enough vars")
    for fram in y:
        rtvarz.append(copy.copy(fram))
    return rtvarz


def main():
    bc = sys.stdin.read()
    prog = sexpdata.loads(bc)
    ip = 0
    pdata = [[State()]]

    def pop_stack():
        v = pdata[-1][-1].varz[-1].pop()
        return v

    ip = pdata[-1][-1].ip
    ins = prog[ip]
    op, args = ins[0], ins[1:]
    if op == sexpdata.Symbol(":yield"):
        _, cnt, recieve_cnt, meta, nex = args
        pdata[-1][-1].ip = nex
    else:
        pass
    while True:
        ip = pdata[-1][-1].ip
        ins = prog[ip]
        # print(ins)
        op, args = ins[0], ins[1:]
        if op == sexpdata.Symbol(":if"):
            if_true, if_false = args
            if pop_stack():
                ip = if_true
            else:
                ip = if_false
        elif op == sexpdata.Symbol(":nop"):
            info, nex = args
            ip = nex
        elif op == sexpdata.Symbol(":put-const"):
            value, nex = args
            pdata[-1][-1].varz[-1].append((value))
            ip = nex
        elif op == sexpdata.Symbol(":put-var"):
            offset, nex = args
            frame, indx = offset
            pdata[-1][-1].varz[-1].append(
                copy.deepcopy(pdata[-1][-1].varz[frame][indx])
            )
            ip = nex
        elif op == sexpdata.Symbol(":call"):
            fn_index, subfn_index, pop_one, target, arg_cnt, ret_cnt, nex = args
            if target != sexpdata.Symbol("plain"):
                raise RuntimeError("only plain targets are currently supported")
            args = list(reversed([pop_stack() for _ in range(arg_cnt)]))
            frame, indx = fn_index
            rout = pdata[-1][-1].varz[frame][indx]
            offset, varz, extvars = rout
            assert varz
            rtvarz = merge(pdata[-1][-1].varz, varz, extvars)
            ip = offset
            if len(subfn_index) > 0:
                subframe, subindx = subfn_index
                subrout = pdata[-1][-1].varz[subframe][subindx]
                suboff, subvarz, subext = subrout
                rtvarz = merge(rtvarz, subvarz, subext)
                ip = suboff
            rtvarz[-1].extend(arg for arg in args)
            pdata[-1].append(State(varz=rtvarz, ip=0))  # ip set after endif
            # check that first instruction is yield and skip it
            ins = prog[ip]
            op, args = ins[0], ins[1:]
            if op != sexpdata.Symbol(":yield"):
                raise RuntimeError("expected a yield-reciever")
            _, cnt, recieve_cnt, meta, nex = args
            if arg_cnt != recieve_cnt:
                raise RuntimeError(
                    f"arg count {arg_cnt} and recieve count {recieve_cnt} are different"
                )
            ip = nex
        elif op == sexpdata.Symbol(":collect"):
            cnt, nex = args
            form = []
            for _ in range(cnt):
                val = pop_stack()
                form = [val] + form
            pdata[-1][-1].varz[-1].append(form)
            ip = nex
        elif op == sexpdata.Symbol(":put-prog"):
            pr, capture, nex = args
            if capture == 0:
                capture_size = 0
            else:
                capture_size = len(pdata[-1][-1].varz)
            p = [pr, [[]], capture_size]
            pdata[-1][-1].varz[-1].append(p)
            ip = nex
        elif op == sexpdata.Symbol(":yield"):
            target, cnt, recieve_cnt, meta, nex = args
            if target == sexpdata.Symbol("plain"):
                rvalues = [pop_stack() for _ in range(cnt)]

                contvarz = list(list(x) for x in pdata[-1][-1].varz)
                cont = [ip, contvarz, 0]

                pdata[-1].pop()

                ip = pdata[-1][-1].ip
                ins = prog[ip]
                op, args = ins[0], ins[1:]
                if op != sexpdata.Symbol(":call"):
                    raise RuntimeError("expected a call")
                fn_index, subfn_index, pop_one, _, arg_cnt, ret_cnt, nex = args

                frame, indx = fn_index
                # update the routine
                pdata[-1][-1].varz[frame][indx] = cont
                if pop_one:
                    pop_stack()
                pdata[-1][-1].varz[-1].extend(reversed(rvalues))

                ip = nex
            elif (
                isinstance(target, list)
                and len(target) == 2
                and target[0] == sexpdata.Symbol("host")
            ):
                instruction = target[1]
                arg = pop_stack()
                if (
                    isinstance(instruction, list)
                    and len(instruction) == 2
                    and instruction[0] == "eval"
                ):
                    res = eval(instruction[1], globals(), {"x": arg})
                    pdata[-1][-1].varz[-1].append((res))
                else:
                    raise RuntimeError(f"host not implemented: {instruction}")
                ip = nex
            elif (
                isinstance(target, list)
                and len(target) == 3
                and target[0] == sexpdata.Symbol("debugger")
            ):
                ip = nex
            elif target == sexpdata.Symbol("halt"):
                break
            else:
                raise RuntimeError("invalid yield")
        else:
            raise RuntimeError(op)
        pdata[-1][-1].ip = ip


if __name__ == "__main__":
    main()
