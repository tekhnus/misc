#!/usr/bin/env python
import sys
import dataclasses
import sexpdata
import copy


@dataclasses.dataclass
class State:
    varz: list = dataclasses.field(default_factory=lambda: [[]])
    ip: int = 0


def head(args):
    (a1,) = args
    h, *t = a1
    return h


def tail(args):
    (a1,) = args
    h, *t = a1
    return t


def is_constant(args):
    (v,) = args
    if isinstance(v, list):
        return []
    if isinstance(v, sexpdata.Symbol) and str(v)[0] != ":":
        return []
    return [[]]


def eq(args):
    a1, a2 = args
    if a1 == a2:
        return [[]]
    return []


def annotate(args):
    (val,) = args
    if isinstance(val, list):
        r = ":list"
    elif isinstance(val, sexpdata.Symbol):
        r = ":symbol"
    elif isinstance(val, str):
        r = ":bytestring"
    elif isinstance(val, int):
        r = ":integer"
    else:
        raise RuntimeError("cannot annotate {}".format(repr(a1)))
    return [sexpdata.Symbol(r), val]


def add(args):
    a1, a2 = args
    return a1 + a2


def cons(args):
    a1, a2 = args
    return [a1, *a2]


def concat_bytestrings(args):
    x, y = args
    return x + y


def repre(args):
    (a1,) = args
    return repr(a1)


def merge(x, y, extvars):
    rtvarz = []
    for fra in x:
        if extvars <= 0:
            break
        rtvarz.append(fra)
        extvars -= 1
    if extvars > 0:
        raise RuntimeError("not enough vars")
    for fram in y:
        rtvarz.append(fram)
    return rtvarz


def main():
    bc = sys.stdin.read()
    bc = bc.replace("[", "(").replace("]", ")").replace("{", "(").replace("}", ")")  # eww
    prog = sexpdata.loads(bc)
    ip = 0
    pdata = [State()]

    def pop_stack():
        v = pdata[-1].varz[-1].pop()
        return v

    def set_stack(target, p):
        tframe, tindx = target
        while tindx >= len(pdata[-1].varz[tframe]):
            pdata[-1].varz[tframe].append(None)
        pdata[-1].varz[tframe][tindx] = p

    ip = pdata[-1].ip
    ins = prog[ip]
    op, args = ins[0], ins[1:]
    if op == sexpdata.Symbol(":yield"):
        _, val_idx, cnt, recieve_cnt, meta = args
        pdata[-1].ip += 1
    else:
        raise RuntimeError("should have started with yield")
    while True:
        ip = pdata[-1].ip
        ins = prog[ip]
        # print(ins)
        op, args = ins[0], ins[1:]
        if op == sexpdata.Symbol(":if"):
            if_index, if_false = args
            if pop_stack():
                ip += 1
            else:
                ip += if_false
        elif op == sexpdata.Symbol(":jmp"):
            nex, = args
            ip += nex
        elif op == sexpdata.Symbol(":put-const"):
            target, value = args
            set_stack(target, copy.deepcopy(value))
            ip += 1
        elif op == sexpdata.Symbol(":copy"):
            target, offset = args
            frame, indx = offset
            set_stack(target,
                copy.deepcopy(pdata[-1].varz[frame][indx]))
            ip += 1
        elif op == sexpdata.Symbol(":move"):
            target, offset = args
            frame, indx = offset
            set_stack(target,
                pdata[-1].varz[frame][indx]
            )
            assert indx + 1 == len(pdata[-1].varz[frame])
            pdata[-1].varz[frame].pop()
            ip += 1
        elif op == sexpdata.Symbol(":call"):
            capture_cnt, indices, pop_one, target, arg_cnt, ret_cnt, top_arg_index, result_idxs = args
            if target != sexpdata.Symbol("plain"):
                raise RuntimeError("only plain targets are currently supported")
            args = list(reversed([pop_stack() for _ in range(arg_cnt)]))
            rtvarz = []
            for frame in range(capture_cnt):
                offset = None
                varz = [pdata[-1].varz[frame]]
                extvars = frame
                rtvarz = merge(rtvarz, varz, extvars)
                ip = offset
            for fn_index in indices:
                assert len(fn_index) == 2
                frame, indx = fn_index
                rout = pdata[-1].varz[frame][indx]
                offset, varz, extvars = rout
                rtvarz = merge(rtvarz, varz, extvars)
                ip = offset
            rtvarz[-1].extend(arg for arg in args)
            pdata.append(State(varz=rtvarz, ip=0))  # ip set after endif
            # check that first instruction is yield and skip it
            ins = prog[ip]
            op, args = ins[0], ins[1:]
            if op != sexpdata.Symbol(":yield"):
                print("jumped to", ins)
                for i in range(ip - 5, ip + 5):
                    if i < 0 or i >= len(prog):
                        continue
                    pref = ">" if i == ip else " "
                    print(i, pref, prog[i])
                raise RuntimeError("expected a yield-reciever")
            _, val_idx, cnt, recieve_cnt, meta = args
            if arg_cnt != recieve_cnt:
                raise RuntimeError(
                    f"arg count {arg_cnt} and recieve count {recieve_cnt} are different"
                )
            ip += 1
        elif op == sexpdata.Symbol(":collect"):
            cnt, indices, target = args
            form = []
            for _ in range(cnt):
                val = pop_stack()
                form = [val] + form
            pdata[-1].varz[-1].append(form)
            ip += 1
        elif op == sexpdata.Symbol(":put-prog"):
            target, capture, nex = args
            if capture == 0:
                capture_size = 0
            else:
                capture_size = len(pdata[-1].varz)
            p = [ip + 1, [[]], capture_size]
            tframe, tindx = target
            while tindx >= len(pdata[-1].varz[tframe]):
                pdata[-1].varz[tframe].append(None)
            pdata[-1].varz[tframe][tindx] = p
            ip += nex
        elif op == sexpdata.Symbol(":yield"):
            target, val_idx, cnt, recieve_cnt, meta = args
            if target == sexpdata.Symbol("plain"):
                rvalues = [pop_stack() for _ in range(cnt)]

                contvarz = pdata[-1].varz
                cont = [ip, contvarz, 0]

                pdata.pop()

                ip = pdata[-1].ip
                ins = prog[ip]
                op, args = ins[0], ins[1:]
                if op != sexpdata.Symbol(":call"):
                    raise RuntimeError ("expected a call")
                capture_cnt, indices, pop_one, _, arg_cnt, ret_cnt, top_arg_index, result_idxs = args

                # update the routine
                frame, indx = indices[-1]
                pdata[-1].varz[frame][indx] = cont
                if pop_one:
                    pop_stack()
                pdata[-1].varz[-1].extend(reversed(rvalues))

                ip += 1
            elif (
                isinstance(target, list)
                and len(target) == 3
                and target[0] == sexpdata.Symbol("host")
            ):
                instruction = target[1:]
                arg = pop_stack()
                if (
                    isinstance(instruction, list)
                    and len(instruction) == 2
                    and instruction[0] == "eval"
                ):
                    res = eval(instruction[1], globals(), {"x": arg})
                    pdata[-1].varz[-1].append((res))
                else:
                    raise RuntimeError(f"host not implemented: {instruction}")
                ip += 1
            elif target == sexpdata.Symbol("panic"):
                raise RuntimeError("panic")
            elif (
                isinstance(target, list)
                and len(target) == 3
                and target[0] == sexpdata.Symbol("debugger")
            ):
                ip += 1
            elif target == sexpdata.Symbol("halt"):
                break
            else:
                raise RuntimeError("invalid yield")
        else:
            raise RuntimeError(op)
        pdata[-1].ip = ip


if __name__ == "__main__":
    main()
